\documentclass{like}

%\selectlanguage{english}
%\selectlanguage{german}

\usepackage{amsmath}
\begin{document}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Ab hier beginnt der Text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  

%\normalsize
\include{Inhalt/Titelseite2}
\include{Inhalt/Bestaetigung}
\include{Inhalt/Acknowledgement} %Optional
\include{Inhalt/Thema_Aufgabenstellung}
\include{Inhalt/Kurzzusammenfassung}
\include{Inhalt/Abstract}
%\include{Inhalt/Abkuerzungsverzeichnis} (nach hinten verschoben)
\include{Inhalt/Content} %Bitte 2x kompilieren - sonst erscheint es nicht


\pagenumbering{arabic} %Seitennummerierung arabisch
\setcounter{page}{1}   %1. Kapitel soll mit Seitenzahl 1 beginnen
%------------------------------------------------------------------

\chapter{Autonomes Fahren}

\section{Stand der Technik}
Gegen Ende des Jahres 2018, also nur wenigen Monaten nachdem diese Zeilen verfasst werden, wird Alphabets Tochterunternehmen Waymo die ersten voll autonomen (Level 5) Fahrzeuge als Taxis in Phoenix in Betrieb nehmen \cite{Waymo}. Dieser historische Moment wird eine Flut an neuen Assistenzsystem nach sich ziehen die in wenigen Jahren das Straßenbild verändern werden. \\
Während sich die traditionellen Automobilhersteller aktuell auf Assistenzsysteme im Bereich von Level zwei und drei konzentrieren, wollen Unternehmen wie Google, GM und Uber alle Zwischenschritte überspringen und direkt voll autonom fahren um fahrerlose Taxiflotten aufzubauen. Dies ist nach aktuellem Stand der Technik jedoch nur kostengünstig und mit Rechnerplattformen welche in bestehende Fahrzeugkonzepte integrierbar sind realisierbar wenn die Fahrzeuge auf eine genaue Umgebungskarte zurückgreifen können. Erst mit Echtzeitupdates und bei einer Genauigkeit von +-10 cm des Kartenmaterials können Fahrzeug auch im innerstädtischen Verkehr autonom fahren \cite{SEIF2016159}. 
Nicht nur im normalen Straßenverkehr ist ein möglichst genaues Wissen der Umgebung von Vorteil, auch bei autonomen Rennserien spielt die Kenntnis über den Rennkurs eine große Rolle. Kann das Fahrzeug nur auf Sicht fahren muss die Geschwindigkeit so gewählt werden, dass innerhalb der Sichtweite angehalten werden kann. Außerdem ist das berechnen einer idealen Trajektorie nur möglich wenn die gesamte Strecke bekannt ist.


\section{Formula Student Driverless}

Die Formula Student ist ein Ingenieurswettbewerb für Studenten. Er hat seine Wurzeln in den USA im Jahre 1981 und wurde ab 1998 auch in Europa ausgetragen.
Dass der Wettbewerb sehr Erfolgreich ist, machen nicht nur die inzwischen fast 700 Teams Weltweit \cite{FsWorldRank:1} deutlich, sondern auch die Anzahl der verschiedenen Events die überall auf der Welt im Sommer stattfinden. Seit dem Jahr 2017 gibt es neben der ursprünglichen Combustion-Klasse und der vor 10 Jahren eingeführten Electric-Klasse auch noch die Driverless-Klasse.
In dieser wird von den Teams ein Altfahrzeug um ein Sensorsystem sowie Aktoren so erweitert, dass das Rennauto die Kurse autonom bestreiten kann.
Der Wettbewerb ist unterteilt in Dynamische und Statische Events. In letzteren werden verschiedene Präsentationen von den Teams verlangt. Diese beziehen sich auf die technische Realisierung, Softwaredesign, Kostenaufstellung und ein Businessplan in dem die Teams ein Konzept erstellen müssen wie man das gebaute Fahrzeug über eine kleine Massenfertigung gewinnbringend verkaufen kann.

Die dynamischen Disziplinen, in denen das Fahrzeug selbstständig fährt, sind hierbei:
\begin{itemize}
	\item Acceleration \\ 75 Meter langer Beschleunigungsstreifen. Punkte werden nach der Zeit nicht nach der Endgeschwindigkeit vergeben.
	\item Skidpad \\ eine liegende 8 bei der an der Engstelle eingefahren wird und jeweils 2 rechte und 2 linke Runden gefahren werden. Die zweite Runde wird jeweils gezählt. Die Abmaße sind exakt vorgegeben.
	\item Trackdrive \\ ein bis zu 800 Meter langer Kurs mit maximal 80 Meter langen Geraden und Kurven mit minimalem Innenradius von 9 Metern. Es werden 11 Runden gefahren und die Teams erhalten im Vornherein keine Möglichkeit Messungen am Kurs vorzunehmen.
\end{itemize}

Für diese Arbeit ist vorallem der Trackdrive von Interesse. Es wird davon ausgegangen dass das Fahrzeug bereits die erste Runde absolviert, und sich damit eine genaue Karte des Rennkurses erstellt hat. Die Messungen und Vergleiche beziehen sich damit auch immer auf einen Kurs der so (wenn auch nicht so kurz) in einem FS-Event für die Driverless Fahrzeuge vorkommen könnte.
 
\begin{figure}[hb!]
	\caption{Zürichs FS-Driverless Fahrzeug im Jahr 2017 während des Trackdrive}
	\includegraphics[width=200pt]{Abbildungen/amz-driverless-long.jpg}
\end{figure}

\section{Ziel der Arbeit}


\chapter{Fahrzeugmodelle}

Wie der Name Model Predictive Control schon verdeutlicht benötigt man eine Systembeschreibung des zu Regelnden Modells. Diese wird genutzt um zukünftige Zustände zu Berechnen und bildet damit einen wichtigen Bestandteil. Desto genauer die Beschreibung das realen System approximiert, desto besser ist die Vorhersage und damit auch die Regelung des Fahrzeugs.
Im folgenden wird zuerst ein kinematisches Fahrzeugmodell eingeführt und dann zu einem dynamischen Modell erweitert.   

\section{Kinematisches Modell}
Unter gewissen Einschränkungen welche weiter unten beschrieben werden kann ein kinematisches Modell die Laterale und Longitudinale Bewegung eines Fahrzeuges mathematisch Beschreiben. In diesem sehr stark vereinfachten Modell werden keine wirkenden Kräfte berücksichtigt, sondern nur die geometrischen Beziehungen des Fahrzeuges genutzt um die Bewegung zu berechnen. \\
Im ersten Schritt werden die jeweils an einer Achse verbundenen Räder zu einem einzigen Zusammengefasst. Dies wird als Bicycle Modell bezeichnet und vereinfacht die Berechnungen erheblich \cite{BicycleModel}. Obwohl auch für Hinterradlenkung möglich, wird im folgenden nur die Vorderradlenkung betrachtet da das Driverless Fahrzeug der Uni Erlangen nur über eine solche verfügt. Die Lenkwinkel welche durch das Bicycle Modell berechnet werden entsprechen nicht den Lenkwinkel am echten Fahrzeug. Die kurveninneren und kurvenäußeren Räder bewegen sich auf zwei Kreisen mit unterschiedlichen Radien, und damit auch verschiedenen Anstellwinkeln. Dies wird in Fahrzeugen durch die Ackermann Lenkung mechanisch abgebildet \cite{rajamani2011vehicle}.


Die nichtlinearen zeitkontinuierlichen Gleichungen basieren auf \cite{rajamani2011vehicle, 7225830} und beschreiben das kinematische Modell bezüglich eines Inertialsystems (siehe Abbildung \ref{fig:kinmodel}),

\begin{figure}[ht!]
	\caption{Kinematisches Modell}
	\includegraphics[width=400pt]{Abbildungen/kin_bicycle.png}
	\label{fig:kinmodel}
\end{figure}

\begin{eqnarray}
\ddot{x}   &= &v  \cos(\psi + \beta)\\
\ddot{y}   &= &v  \sin(\psi + \beta)\\
\dot{\psi} &= &\frac{v}{l_r} \sin(\beta) \\
\dot{v}    &= &a \\
\beta      &= &\arctan(\frac{l_r}{l_f + l_r} \tan(\varphi_f))
\end{eqnarray}

in dem \(x\) und \(y\) die Koordinaten des Schwerpunktes im Inertialsystem darstellen. 
\(\varphi\) ist die Orientierung und \(v\) die Geschwindigkeit des Fahrzeugs. \(l_f\) und \(l_r\) sind die Abstände der vorderen (\(l_f)\) und hinteren (\(l_r)\) Achsen zum Schwerpunkt.
Der Schwimmwinkel (\(\beta\)) ist der Winkel  zwischen der Bewegungsrichtung des Fahrzeugs im Schwerpunkt und der Fahrzeuglängsachse bei der Kurvenfahrt. Die Beschleunigung \(a\) bezieht sich ebenfalls auf den Schwerpunkt und zeigt immer in die gleiche Richtung wie die Geschwindigkeit. \\
Die Parameter lassen sich in zwei Bereiche unterteilen:

\begin{itemize}
	\item Steuerparameter  \\
			\(a\), \(\varphi\)
	\item Zustandsgrößen \\
			\(X\), \(Y\), \(v\), \(\varphi\)
	
\end{itemize}


Die Annahme eines kräftefreien Modells, bei dem das Vorderrad genau in die Richtung rollt in die es zeigt, ist nur bis etwa 5 m/s plausibel \cite{rajamani2011vehicle}. Danach müssen die Kräfte welche die Reifen auf die Straße übertragen können mit betrachtet werden. Diese werden dann im dynamischen Modell genutzt um eine genauere Vorhersage berechnen zu können.

Die für das kinematische Modell angenommenen Werte stammen vom Fahrzeug aus dem Jahr 2017 des High Octane Motorsports Verein der Uni Erlangen (siehe \ref{vehicleParam}). Die Beschleunigung \(a\) wurde für den besten \textit{Acceleration} Durchgang in FSG-2017 mit der Zeit $t = 4.5s$ und der Endgeschwindigkeit $v = 32.78 \frac{m}{s\textsuperscript{2}}$ berechnet. Für 
\begin{equation}
	a = \frac{v}{t} 
\end{equation}
erhält man eine mittlere Beschleunigung von $7.284 \frac{m}{s\textsuperscript{2}} $.

Überprüft man die Werte mit der Formel zum berechnen der zurück gelegten Entfernung 
\begin{equation}
x = \frac{1}{2} * a * t^2  
\end{equation}
liegt man mit \(73.75m\) nur zwei Prozent neben der genauen Streckenlänge von \(75m\).


\section{Reifenmodell}
\label{tireModel}
Da die Reifen der einzige Kontaktpunkt zwischen Fahrbahn und Fahrzeug sind,  beeinflusst er das Fahrverhalten maßgeblich. Aufgabe des Reifens ist es, sämtliche Kräfte und Momente zu übertragen, um eine optimale Straßenlage zu erzielen. Demzufolge ist der Reifen das Bauteil, welches die Fahrleistungen am stärksten einschränkt.

Die Kräfte die ein Reifen auf die Straße übertragen kann hängen von dem Schräglaufwinkel, dem Schlupf und der Radlast ab. Die Radlast \(F_z\) berechnet sich aus der Normalkraft und der Radlastverteilung und wird im folgenden als konstant angesehen.
Die Seitenführungskraft \(F_y\) wirkt bei einer Kurvenfahrt der Fliehkraft entgegen und hält das Fahrzeug auf der Spur solange ein Kräftegleichgewicht besteht. Als Schräglaufwinkel bezeichnet man den von der Radmittelebene \(\delta\) (Lenkwinkel) und der Bewegungsrichtung \(\theta_{vf}\) des Fahrzeugs eingeschlossenen Winkel (siehe Abbildung \ref{fig:linLat}). Dieser ist notwendig, damit der Reifen eine Seitenkraft aufbauen kann. \\

\begin{equation}
\alpha_f = \delta - \theta_{vf}
\end{equation}
Der gleiche Zusammenhang gilt auch für das hintere Rad welches jedoch in unserem Fall nicht gelenkt wird.
\begin{equation}
\alpha_r = \theta_{vr}
\end{equation}


\begin{figure}[ht!]
	\includegraphics[width=400pt]{Abbildungen/linLat.png}
	\caption{Schräglaufwinkel}
	\label{fig:linLat}
\end{figure}




Für kleine Schräglaufwinkel besteht ein linearer Zusammenhang aus lateraler Kraft und Winkel. 
\begin{eqnarray}
F_{yf} = C_\alpha \alpha_f \\
F_{yr} = C_\alpha \alpha_r
\end{eqnarray}

Am Schaubild \ref{fig:pacejka} lässt sich dieser Bereich sehr gut erkennen.
Auch dass für größere Schräglaufwinkel die Kräfte anders berechnet werden müssen ist ersichtlich. Hierfür wird die so genannte \textit{Magic Formula}  \cite{magicFormula} verwendet. Dabei handelt es sich um eine mathematische Gleichung die sehr gut Messkurven approximiert welche auf Testständen gemessen werden.
Es wurde 1993 von Pacejka und Bakker entwickelt, und eignet sich sowohl für die Berechnung der longitudinalen wie auch der lateralen Kräfte . Bei Eingabe des Schräglaufwinkels in \(x\) erhält man die lateral auf die Straße wirkende Kraft \(F_y\). 
 \begin{equation}
 F_y = D\sin[C\arctan{Bx - E(Bx - \arctan(Bx))}]
 \label{eq:magicF}
 \end{equation}
 
Die Parameter, welche für die \textit{Magic Formula} benötigt werden, wurden vom High Octane Motorsports e.V. zur Verfügung gestellt und beziehen sich auf das Fahrzeug des Jahres 2017.
 
\begin{tabular}[t]{lr}
 	B	&	0.71 \\
 	C	&	1.40 \\
 	D	&	1.00 \\
 	E	&  -0.20 \\
\end{tabular}
 
 
 \begin{figure}[ht!]
 	\includegraphics[width=350pt]{Abbildungen/pacejka.png}
 	\caption{Tire Model}
 	\label{fig:pacejka}
 \end{figure}
 
Ähnlich wie bei \(F_y\) wird auch die Kraft welche das Fahrzeug in Längsrichtung beschleunigt \(F_x\) durch den Schlupf berechnet. Dieser hängt direkt von der Geschwindigkeit und Raddrehzahl ab. 
Da für die bestimmung dieser jedoch eine Motorsimulation vonnöten wäre, wird \(F_x\) direkt aus der Motorleistung, Reibung und Luftwiderstand berechnet (siehe Section \ref{dynModel}) und durch \(F_{max}\) begrenzt. \(F_{max}\) entspricht der maximalen Kraft, die der Reifen übertragen kann.\\
\begin{equation}
 	F_x <= F_{max}
\end{equation}
Der Zusammenhang zwischen lateraler und longitudinaler Kraft wird über den \textit{Kammschen Kreis} Modelliert (siehe Schaubild \ref{fig:kamKreis}). Dieser schränkt die wirkenden Kräfte so ein, dass die Hypotenuse aus \(F_x\) und \(F_y\) sich maximal auf einem Einheitskreis bewegen kann. Dieser hat den Radius der maximalen Kraft die der Reifen übertragen kann (\(F_{max}\)).

\begin{eqnarray}
	F <= F_{max} \\
	F = \sqrt{F_x^2 + F_y^2}  \\
	|F_y| <= F_{max}^2 - F_x^2
\end{eqnarray}
In Kombination mit \ref{eq:magicF} erhält man
 \begin{equation}
	|D\sin[C\arctan{Bx - E(Bx - \arctan(Bx))}]| <= F_{max}^2 - F_x^2
 \end{equation}

\begin{figure}[ht!]
	\caption{Kammscher Kreis}
	\includegraphics[width=400pt]{Abbildungen/kamKreis.jpg}
	\label{fig:kamKreis}
\end{figure}
	
	



Mit dem Wissen wie die longitudinalen und lateralen Kräfte berechnet werden, kann nun ein genaueres Systemmodell genutzt werden.

\section{Dynamisches Fahrzeugmodell}
\label{dynModel}

Die Basis ist wie auch schon beim kinematischen Modell das \textit{bicycle model}. Es wird nun um die durch das zweite newtonsche Gesetz entstehenden Kräfte entlang der \(y\)-Achse erweitert.

\begin{equation}
ma_y = F_{yf} + F_{yr}
\end{equation}   


Wobei \(a_y\) aus zwei Anteilen besteht, der Querbeschleunigung \(\ddot{y}\) und der Zentripetalkraft \(\dot{x} \dot{\psi}\).  
Die Kräfte \(F_{yf}\) und \(F_{yr}\) greifen jeweils am vorderen \((.)_f\) und hinteren \((.)_r\) Rad (siehe Schaubild \ref{fig:dynModel}). 

\begin{figure}[hb!]
	\caption{Dynamic Vehicle Model}
	\includegraphics[width=350pt]{Abbildungen/dynModel.png}
	\label{fig:dynModel}
\end{figure}




Unter Einbezug des Trägheitsmoments \(I_z\) des Fahrzeugs, kann das Drehmoment um die \(z\)-Achse betrachtet werden.
\begin{equation}
I_z \ddot{\psi} = l_f F_{yf} - l_r F_{yr}
\end{equation}

Als Ergebnis lassen sich die Gleichungen für Longitudinal-, Lateral- und Drehbewegung aufstellen.

\begin{eqnarray}
	m \ddot{x} = m \dot{y} \dot{\psi} + F_x \\
	m \ddot{y} = - m \dot{x} \dot{\psi} + F_y \\
	I \ddot{(\psi)} = l_f F_{yf} - l_r F_{yr}
\end{eqnarray}

Die Kräfte \(F_{x}\) und \(F_{y}\) wirken auf den Schwerpunkt des Fahrzeugs und setzen sich zusammen aus den Einzelkomponenten der Radkräfte.

\begin{eqnarray}
F_x = F_{xf} + F_{xr} \\
F_y = F_{yf} + F_{yr}
\end{eqnarray}

Diese hängen ab von den lateralen \((.)_C\) und longitudinalen \((.)_l\)    Radkräften und dem Lenkwinkel. Da das Vorderrad nicht angetrieben ist besitzt es keinen longitudinalen Anteil. 

\begin{eqnarray}
F_{xf} =& - 2 F_{Cf} \sin(\delta_f) \\
F_{yf} =& 2 F_{Cf} \cos(\delta_f) \\
F_{xr} =& 2 F_{lr} \\
F_{yr} =& 2 F_{Cr}
\end{eqnarray}
Es ist zu beachten, dass das Fahrzeug in der Realität vier Reifen besitzt und daher die Kräfte mit zwei multipliziert werden müssen.


Die Kräfte \(F_{Cf}\) und \(F_{Cr}\) werden durch die \textit{magic formula} im letzten Abschnitt \ref{tireModel} berechnet.
Die dafür benötigten Schräglaufwinkel werden durch folgende Formeln bestimmt:

\begin{eqnarray}
\alpha_f = \delta_f - \arctan(\frac{\dot{y} + l_f \dot{\psi}}{\dot{x}}) \\
\alpha_r = - \arctan(\frac{\dot{y} - l_r \dot{\psi}}{\dot{x}})
\end{eqnarray}

\subsection*{Longitudinale Kräfte}
Da wie bereits im letzten Abschnitt angedeutet können die longitudinalen Kräfte nur genau berechnet werden, wenn ein Motor simuliert wird. Da dies den Umfang der Arbeit sprengt werden die Kräfte direkt über die Motorleistung und \(F_max\) bestimmt.
\begin{eqnarray}
	F_{lr_{acc}} = \frac{P_{engine} * throttle }{|\dot{x}|} \\
	F_{lr_{acc}} <= F_{max} \\
	F_{lr_{dec}} = - F_{max} * break\\
\end{eqnarray}
Es wird von einer idealen \textit{Launchcontrol} ausgegangen (kein durchdrehen der Reifen).
Beschleunigt das Fahrzeug wirkt nicht nur die Rollreibung der longitudinalen Kraft des Motors entgegen, sondern auch der Luftwiderstand. Es wird von einem Rennkurs ausgegangen der keine Steigung besitzt.
\begin{eqnarray}
F_{reib} = m \mu g \\
F_{aero} = \frac{1}{2} \rho C_d A_f \dot{x}^2
\end{eqnarray}

Die resultierenden longitudinalen Kraft 
\begin{eqnarray}
F_{acc} = F_{lr_{acc}} - F_{reib} - F_{aero}\\
\end{eqnarray}

werden mit den lateralen Kräften im Kammschen Kreis verrechnet und in der finalen Bewegungsgleichung verwendet.

\begin{eqnarray}
\dot{X} =& \dot{x} \cos(\psi) - \dot{y} \sin(\psi) \\
\dot{Y} =& \dot{x} \sin(\psi) - \dot{y} \cos(\psi) \\
m \ddot{x} =& m \dot{y} \dot{\psi} + 2F_{xf} + 2 F_{xr}\\
m \ddot{y} =& - m \dot{x} \dot{\psi} + 2 F_{yf} + 2 F_{yr} \\
I \ddot{\psi} =& 2 l_f F_{yf} - 2 l_r F_{yr} \\
\end{eqnarray}

Das Gleichungssystem kann auch in diskreter Form aufgestellt werden.

\begin{eqnarray}
X_{k+1} =& X_k + \Delta t(\dot{x}_k \cos(\Psi_k) - \dot{y}_k \sin(\Psi_k) \\
Y_{k+1} =& Y_{k} + \Delta t(\dot{x}_k \sin(\Psi_k) - \dot{y}_k \cos(\Psi_k) \\
\Psi_{k+1} =& \Psi_k + \Delta t \dot{\psi}_k \\
\dot{x}_{k+1} =&  \dot{x}_k + \Delta t (\frac{2F_{xf_k} + 2 F_{xr_k}- F_a}{m} + \dot{y}_k \dot{\psi}_k) \\
\dot{y}_{k+1} =&  \dot{y}_k + \Delta t (\frac{2 F_{yf_k} + 2 F_{yr_k}}{m} - \dot{x}_k \dot{\psi}_k)  \\
\dot{\psi}_{k+1} =& \dot{\psi}_k + \Delta t \frac{2 l_f F_{yf} - 2 l_r F_{yr}}{I} \\
\end{eqnarray}

Im dynamische Fahrzeugmodell ändert sich damit auch der Zustandsvektor: \\
\(X\), \(Y\), \(x_d\), \(y_d\), \(\Psi\), \(\dot{\psi}\) \\
Der Steuervektor bleibt gleich.

Die zur Berechnung verwendeten Fahrzeugparameter wurden für das zum Verfassen dieser Arbeit aktuellstem Fahrzeug erfasst. Die Informationen hierfür sind aus dem CAD-Modell oder im Feld erfassten Testdaten entnommen worden (siehe Anhang).


\begin{table}[]
	\centering
	\begin{tabular}{l|l|l}
		\hline
		Formelzeichen	& Wert & Einheit \\ \hline
		\(l_f\)	&	1.09 & m\\
		\(l_r\)	&	0.9 & m\\
		\(l_b\)	&	1.99 & m \\
		\(r\)	&	0.2 & m \\
		\(m\)	&  	163 & kg\\
		\(I\)	&  	1000 & kgm\textsuperscript{2}\\
		\(A_f\)	&  	1.5 & m\textsuperscript{2}\\
		\(P_{engine}\) &  40,5 & kW\\
		\(C_d\)	&  	1.5 & - \\
		\(\rho\)	&  	1.225 & kg / m\textsuperscript{3}\\
		\(F_{max}\)	&  	3 & kN \\ 
	\end{tabular}
	\caption{Vehicle Parameter}
	\label{vehicleParam}
\end{table}







\chapter{Trajektionsplanung und Fahrzeugregelung}

Um für das Fahrzeug ideale Trajektorien zu berechnen, und gleichzeitig das Rennauto in Echtzeit zu regeln wurde ein Model Predictive Control Ansatz gewählt. Dieses Verfahren basiert auf der Optimierung eines nichtlinearen Programms.


\section{Optimierung}
Das Konzept der Optimierung ist es, eine gegebene Funktion \(f(\vec{x})\), auch als Kostenfunktion bezeichnet, zu mini- oder maximieren. 
Dies wird in einer Vielzahl von Anwendungsgebieten genutzt.
Zum Beispiel zur Berechnung von Profit / Verlust in einem Betrieb, Geschwindigkeit oder Distanz in einem physikalischen Problem oder der erwartete \textit{return of investment} für ein Geldanlage.  
Die Bezeichnung lineare Programmierung bezieht sich auf die Lösung eines  Optimierungsproblems und hat nichts mit dem eigentlichen Programm zu tun.

Die allgemeine mathematische Definition eines Optimierungsproblems ist

 $minimize$  
  \noindent\hspace*{3mm}%
 $f(\vec{x}) $ \\
 $subject$  $to$ 
 \noindent\hspace*{3mm}%
 $g_i(\vec{x})$ $\leq$ $0,$ $i=1,2,...,p$  \\
 \noindent\hspace*{22mm}%
 $h_j(\vec{x})= 0,$ $j= 1,2,...,m$\\ 
 \noindent\hspace*{22mm}%

 
 Der Eingabeparameter $\vec{x}$ sei aus $\Re \textsuperscript{n} $, das heißt, das Problem hängt von \(n\) Einflussparameter ab, die im Vektor $\vec{x}$ eingelagert sind. Die Zielfunktion $f:D \rightarrow \Re $ sei einmal stetig differenzierbar. Weiterhin sind die Nebenbedingungen in Ungleichheitsform $g_i:D \rightarrow \Re$ mit $1\leq i \leq p$ und in Gleichheitsform $h_j:D \rightarrow \Re$ mit $1\leq j \leq m$ gegeben.
 In dem \(f(\vec{x})\) durch \(-f(\vec{x})\) ersetzt wird, kann aus dem Minimierungs, ein Maximierungsproblem gemacht werden.  
  
 Eine Optimierungsproblem hat nicht immer eine Lösung. Die Ungleichungen, welche den Suchraum einschränken, können sich widersprechen (z.b. $x \leq 0 $ und $x > 0$). In diesem Fall gibt es keine Lösung. Außerdem kann das Problem unbeschränkt sein, was unendlich viele zulässige Lösungen zur Folge hätte und damit auch als nicht lösbar eingestuft wird. 
 
 Ein lineares Programm (alle Funktionen sind linear) lässt sich in Matrixschreibweise darstellen. Es besteht aus $A \in \Re \textsuperscript{m,n}$ und zwei Vektoren $b \in \Re \textsuperscript{m,1}$ und $c \in \Re \textsuperscript{1,n}$. \\

\[ \left( \begin{array}{cccc}
a_{11} x_1 + & ... & + a_{1n} x_n & \leq b_1 \\   	
a_{21} x_1 + & ... & + a_{2n} x_n & \leq b_2 \\ 
. & . & . & . \\
. & . & . & . \\
a_{m1} x_1 + & ... & + a_{mn} x_n & \leq b_m \\
\end{array} \right)\] 
 
 Das Optimierungsverfahren sucht eine Lösung für den Vektor \(\vec{x}\) welcher sowohl die linearen Bedingungen erfüllt, als auch die Zielfunktion 
 $cx=c_1 x_1 + ... + c_n x_n$ minimiert.
 Die Kurzschreibweise für dieses Gleichungssystem ist: \\
 $min \{ c\textsuperscript{T}x | Ax \leq b, x \geq 0 \}$
 
Besonders einfach veranschaulichen lässt sich die Lösung des Problems geometrisch im zweidimensionalen Raum, so dargestellt in Abbildung \ref*{fig:linOpt}.

\begin{figure}[ht!]
	\caption{Lineare Optimierung}
	\includegraphics[width=350pt]{Abbildungen/linOpt.png}
	\label{fig:linOpt}
\end{figure}

Jede Ungleichung $a_i x \leq b_i$ teilt den Suchraum in zwei Hälften, eine mit zulässigen Punkten und eine ohne. Die Punkte auf der Grenze sind ebenfalls zulässig. Die Menge der Punkte welche alle Ungleichungen erfüllt, ist genau der Schnitt dieser Halbräume, also die Menge aller Punkte, die für jede Ungleichung in der jeweiligen zulässigen Hälfte des Raumes liegt. 
Der Punkt, der die Kostenfunktion $c: x \rightarrow c\textsuperscript{T} x$ minimiert, liegt auf den Kanten der Ungleichungen und wird durch Verschiebung der Hyperebene $ \{x| c\textsuperscript{T} x = 0 \}$ in Richtung des Vektors \(c\) gefunden. 


 \subsection*{Lösungsverfahren}

\subsection{Simplex - Verfahren}
Zur besseren Veranschaulichung wird zuerst kurz das Simplex verfahren erklärt welches für die meisten Optimierungsverfahren am schnellsten ist.

  
 \subsection{Innere-Punkte-Verfahren}  
 Im Folgenden wir das Innere-Punkte-Lösungsverfahren für lineare, quadratische und nichtlineare Optierungsprobleme kurz vorgestellt. Die Idee hinter dem Verfahren ist es, die Positivitätsbedingungen $x >= 0$ durch logarithmische Strafterme $-\mu \ln x_i $ zu ersetzen. Dadurch nähert man sich nicht von außen entlang der Grenzen der Hyperebene, sondern durch das Innere des zulässigen Bereiches (\ref{fig:iterPoint}). 
  
  \begin{figure}[ht!]
  	\caption{Innere-Punkte-Verfahren}
  	\includegraphics[width=350pt]{Abbildungen/iterPoint.png}
  	\label{fig:iterPoint}
  \end{figure}
 
 Das zu Lösende Problem lautet dann: \\
 $min \{ c\textsuperscript{T}x - \mu \sum_{i}^{n} \ln x_i | Ax \leq b\}$ \\
 Für kleine Werte von x wird $-\ln x $ sehr groß. Dies nutzt man aus, um kleine Werte von \(x\) zu Bestrafen und damit die Suche der Lösung immer innerhalb des zulässigen Bereiches zu führen. Während der Suche wird \(\mu\) sukzessive verkleinert, bis im Grenzfall $ \mu \rightarrow 0$ das Barriereproblem gegen die Lösung des Optimierungsproblemes konvergiert (siehe Abbildung \ref{fig:iterPointLn}).\\
   
   \begin{figure}[ht!]
   	\caption{Logarithmische Barrierefunktionen}
   	\includegraphics[width=350pt]{Abbildungen/intPointLn.png}
   	\label{fig:iterPointLn}
   \end{figure}
 
 Die Grundvorraussetzung ist, dass das Problem in Standardform vorliegt. Ein Minierungsproblem wird in ein Maximierungsproblem umgewandelt.
 Alle Ungleichungen $g_i(\vec{x})$ $\leq b_i$ werden unter Zuhilfenahme von \textit{slack}-Variablen so umgewandelt, dass die Gleichungen im Format $g_i(\vec{x}) - b_i -s_i$ $=  0$ vorliegen. \\
 Als Beispiel wird $a_{i1}x_1 + a_{i2} x_2 + a_{in} x_n\leq b_i$ umgewandelt in 
 $a_{i1} x_1 + a_{i2} x_2 + a_{in} x_n - b_i +s_i = 0$ mit $s_i \geq 0$. Ungleichungen der Form $a_{i1} x_1 + a_{i2} x_2 + a_{in} x_n\geq b_i$ werden  durch  
 $a_{i1}x_1 + a_{i2} x_2 + a_{in} x_n - b_i - s_i = 0$ mit $s_i \geq 0$ ersetzt.

 Nach der Umformung 

 

  
 
   

   
   Warmstart

 
\subsection{Automatische Ableitung}
 
 
 
 
\section{Model Predictive Control}
Bei \ac{MPC} handelt es sich um einen fortschrittlichen Algorithmus, mit dem sehr komplexe, multivariable Regelungsprobleme lösen lassen. Soll ein Prozess kontrolliert werden, welcher mehrere Ein- und Ausgänge besitzt und gleichzeitig Ungleich- und Gleichheitsbedingungen erfüllen werden müssen, ist \acs{MPC} ein mächtiges Werkzeug. Vorausgesetzt ein ausreichend genaues Modell des Prozesses vorhanden, können unter ausnutzen von Messungen und dem Modell zukünftige Zustände des Prozesses berechnet werden. Diese Information wird genutzt um die Eingangsparameter abhängig von dem gewünschten Verhalten, für zukünftige Steuerparameter, zu Berechnen \cite{seborg2010process}. \\
Einige wichtige Vorteile von \ac{MPC} sind: \\
(1) das sehr gute annähern an Prozessgrenzen und damit ein hoher Durchsatz/Effizienz, (2) Einschränkungen der Eingangs und Ausgangsgrößen werden berücksichtigt, (3) die Vorhersage des Fahrzeugzustands kann genutzt werden um mögliche Probleme frühzeitig zu detektieren.
Seit den späten 70ern bis in die frühen 2000er wurde \ac{MPC} vor allem in der Chemiebranche genutzt um die komplexen multivariablen Regelungsprozesse bei zum Beispiel der Ölraffinerie zu Steuern. Für diese Aufgabengebiete war \acl{MPC} hervorragend geeignet, da die Prozesse im Vergleich zu anderen Regelungsaufgaben sehr langsam sind und damit die geringe Rechenleistung der damaligen Zeit ausreichend war. 
Gerade in den letzten Jahren, mit stark gestiegener Prozessorleistung, sind die Einsatzgebiete vielfältiger geworden. Auch die Steuerung hoch dynamischer Systeme wie Quadcopter \cite{quadcopterMpc} oder Fahrzeugen \cite{carMPC} ist inzwischen möglich. 

\subsection{Funktion}
Der systematische Ablauf eines \ac{MPC}- Algorithmus ist in Abbildung \ref{fig:mpcBlock} aufgezeigt.  

  \begin{figure}[ht!]
  	\caption{Block Diagramm zu MPC}
  	\includegraphics[width=350pt]{Abbildungen/mpcBlockDiagram.png}
  	\label{fig:mpcBlock}
  \end{figure}

Die Funktion lässt sich in mehrere Schritte unterteilen:
\begin{itemize}
	\item Zustandsschätzung \\ Im ersten Schritt wird der aktuelle Zustand des System erfasst und als Ausgangspunkt für die Berechnung des Optimierungsproblems festgelegt.
	\item Optimierung \\ In diesem Schritt werden die zukünftigen Zustände des System berechnet und welche Steuerparameter von Nöten sind um eine Kostenfunktion zu minimieren. Diese entspricht im industriellen Umfeld zum Beispiel einer Optimierung der Fertigungsrate, Kostenreduktion,  Temperatursteuerung, etc.
	\item Steuerung \\ Die berechneten Steuerparameter werden auf dem realen System angewandt. Danach geht es wieder beim ersten Schritt los.   
\end{itemize}


Die Mächtigkeit von \ac{MPC} basiert auf der Prädiktion des Systemverhaltens. Ein präzises Vorhersagen setzt daher eine möglichst gute Systembeschreibung voraus. Je genauer diese an die Realität heran reicht, desto weiter in die Zukunft können die Systemzustände berechnet werden. Außerdem kann das System näher an seine Systemgrenzen geführt werden. \\
Bei \acl{MPC} handelt es sich um ein sogenanntes \textit{finite-horizon} Verfahren, das heißt Optimierung wird immer für einen bestimmten Zeitraum in die Zukunft durchgeführt $ [t_0, t_0 + T] $. Dieser Bereich \(T\) wird dann in \(k\) Schritte unterteilt für die jeweils ein Prädiktionsschritt berechnet wird. Dieser geht aus dem vorherigen Zustand $k -1$ und den dazu gehörigen Steuergrößen hervor. Nach dem der Optimierer die für die Kostenfunktion idealen Steuergrößen für den gesammten Prädiktionsvektor berechnet hat, wird nur der erste Steuerwert ausgewählt und zur Regelung im realen System eingesetzt. \\




Wie bereits erwähnt wurde, berücksichtigt der \ac{MPC}-Ansatz auch  Bedingungen (constraints) mit welchen man den Suchraum einschränkt. Diese sind im Falle eines Rennautos zum Beispiel die maximale Geschwindigkeit, Lenkeinschlag, Beschleunigung und Bremskraft. Ebenfalls ein sehr gutes Beispiel ist die Änderungsrate der Querbeschleunigung, welche ein direkter Indikator für den Komfort einer autonomen Fahrzeugs während der Fahrt darstellt.

\section{Python}

Zu Beginn der Masterarbeit wurde zuerst die Programmiersprache Python verwendet um das \ac{MPC} zu programmieren. Als Optimierer wurde ein \textit{Sequential Least SQuarez Programming}-Algorithmus verwendet. Dieser ist direkt in die SciPy-Bibliothek integriert und unterstützt Eingangs-, Ausgangs- und Zustandsbeschränkungen ohne die es nicht möglich ist das \ac{MPC} für die Fahrzeugregelung auszulegen. So lange die Anzahl der Prädiktionsschritte klein bleibt und 10 nicht überschreitet ist die Ausführungszeit gering genug um eine Updaterate von 20Hz zu erreichen. 

\begin{figure}[ht!]
	\includegraphics[width=400pt]{Abbildungen/juliaBenchmark.png}
	\caption{Ausführungszeiten für verschiedene Horizontlängen}
	\label{fig:juliaBench}
\end{figure}

Bei größeren Prädiktionsvektoren fällt die Geschwindigkeit jedoch sehr schnell ab da die automatische Ableitung benötigt wird. Diese lässt sich in Python mit Frameworks wie \textit{CasADi} \cite{Casadi:1} integrieren. Auf Grund der schlechten Dokumentation wurde nach einer alternativen Programmiersprache gesucht, die für diese Art von Problem besser geeignet ist.


\section{Julia}
Die Sprache die dies ermöglicht ist die Programmiersprache \text{Julia}. Sie wurde im Jahr 2009 von Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and Alan Edelman ersonnen und ist damit noch eine sehr junge Sprache. Sie ist vor allem für numerische Analyse und wissenschaftliche Berechnungen erfunden worden und bietet in diesen Bereichen viele Funktionalitäten. Ebenfalls ein wichtiges Ziel bei der Entwicklung war es, ohne vorheriges Kompilieren sehr schnell zu sein und trotzdem weiterhin das \textit{general-purpose} Paradigma zu erfüllen. Ein Vergleich der Berechnungsgeschwindigkeit verschiedener Sprachen bezüglich viel genutzten Funktionen im wissenschaftlichen Umfeld ist in dem Benchmark \ref{fig:juliaBench} zu sehen.

\begin{figure}[ht!]
	\includegraphics[width=450pt]{Abbildungen/juliaBenchmark.png}
	\caption{Ausführungszeiten für verschiedene Sprachen}
	\label{fig:juliaBench}
\end{figure}

Die wichtigsten Feautres von Julia sind:
\begin{itemize}

	\item multiple dispatch: Wird genutzt um die gleiche Methode für verschiedene Kombinationen an Eingabeparametern oder Variablentypen zu überladen. Bei dem Funktionsaufruf wird die am besten passende Methodendefinition aufgerufen. \\
	\item type inference: Automatische detektieren des Datentyps. Dies befreit den Programmierer vom festlegen des Typs und ermöglicht trotzdem Typprüfung. \\
	\item \ac{JIT} Kompilierung: Ein System in dem ein \ac{JIT} Kompilierer implementiert ist, wandelt den Computer Code erst zur Laufzeit in Bytecode um. Der große Vorteil ist, dass während der Ausführung kontinuierliche Analysen durchgeführt werden, um Bereiche ausfindig zu machen die durch ein neukompilieren eine signifikanten verbesserung bei der Ausführungszeit erfahren würden. \\
\end{itemize}




\chapter{Implementierung}

\section{MPC for Racecar}

Es wurde ein kombinierter Ansatz gewählt, anstatt das Problem auf einen Linearen und Longitudinalen Regler aufzuteilen. Die Vorteile, Nachteile sind:

It is possible to divide the problem defined in Section 1.4 in longitudinal and lateral control. This division has
some advantages, namely:
• Easier to tune the parameters and weight matrices. Each problem has different states and control inputs to
be tuned;
• More robust. If one of the controllers fails the other is still able to function with certain limitations;
• Two less complex problems. The complexity grows quadratically with the number of states;
• Easier to test. The controllers can be tested independently.
But it also has some disadvantages, namely:
25• Harder to design. It requires two problems to be defined;
• Harder to integrate. Both controllers need to communicate in between each other and match their inputs at
every time step;
• Loss of optimality. Both controllers cannot calculate their outputs at the same time, so only the last one to
calculate its control outputs is calculated based on the exact references.
The advantages outweigh the disadvantages, so the division is made.

\subsubsection{Suchbereich einschränken (constraint)}

\section{Simulation}




\chapter{Evaluierung}

\section{Verifizierung der Fahrzeugmodelle}
\section{Regelung verschiedener Modelle}
\section{Kostenfunktionen}



\chapter[Ausblick]{Zusammenfassung und Ausblick}
\section{Dynamisches Fahrzeugmodell im MPC}
\section{Trajektionsregelung}
\section{Zweispurmodell}
\section{Zusammenfassung}



\appendix

\include{Inhalt/Anhang}

\include{Inhalt/Abkuerzungsverzeichnis}

%\bibliographystyle{IEEEtran}
\bibliographystyle{alpha}
\bibliography{Inhalt/literatur}

% Bitte noch Index anhängen (kommt unter Linux zu Fehlermeldungen)
%\input{Inhalt/index}

%bitte Lebenslauf anhängen !!!
% kommt unter Linux zu Fehlermeldungen
\input{Inhalt/cvalt}



\end{document}



 
